# Roadmap —Ä–∞–∑–≤–∏—Ç–∏—è –ø—Ä–æ–¥—É–∫—Ç–∞ Cryptography Vulnerability Scanner

## üéØ –¢—Ä–∏ –∫–ª—é—á–µ–≤—ã—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∞–∑–≤–∏—Ç–∏—è

–≠—Ç–æ—Ç –¥–æ–∫—É–º–µ–Ω—Ç –æ–ø–∏—Å—ã–≤–∞–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é —É–ª—É—á—à–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞ –ø–æ —Ç—Ä–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º:
1. **–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞–º –†–§** (–§–°–¢–≠–ö, –§–°–ë, –ì–û–°–¢)
2. **–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –Ω–∞ –∫—Ä–∏–ø—Ç–æ–∞–∫—Ç–∏–≤—ã** (—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏, –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã, SBOM)
3. **–†–∞–∑–≤–∏—Ç–∏–µ –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏** (–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è, –∞–Ω–∞–ª–∏—Ç–∏–∫–∞, –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏)

---

## üìú –ß–∞—Å—Ç—å 1: –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–µ–≥—É–ª—è—Ç–æ—Ä–∞–º –†–§

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è
–°–∫–∞–Ω–µ—Ä –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–±—â–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã (PCI-DSS, TLS best practices), –Ω–æ –Ω–µ –∞–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω –ø–æ–¥ —Ä–æ—Å—Å–∏–π—Å–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è.

### –¶–µ–ª–µ–≤—ã–µ —Ä–µ–≥—É–ª—è—Ç–æ—Ä—ã –∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã

#### 1.1. **–§–°–¢–≠–ö –†–æ—Å—Å–∏–∏ (–§–µ–¥–µ—Ä–∞–ª—å–Ω–∞—è —Å–ª—É–∂–±–∞ –ø–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–º—É –∏ —ç–∫—Å–ø–æ—Ä—Ç–Ω–æ–º—É –∫–æ–Ω—Ç—Ä–æ–ª—é)**

##### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –§–°–¢–≠–ö –∫ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏:
- **–ü—Ä–∏–∫–∞–∑ –§–°–¢–≠–ö ‚Ññ17** (2014): –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –ø–æ –∑–∞—â–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **–ü—Ä–∏–∫–∞–∑ –§–°–¢–≠–ö ‚Ññ21** (2013): –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –ò–°–ü–î–Ω
- **–ü—Ä–∏–∫–∞–∑ –§–°–¢–≠–ö ‚Ññ239** (2023): –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∫–≤–∞–Ω—Ç–æ–≤–æ-—É—Å—Ç–æ–π—á–∏–≤–æ–π –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–∏

##### –ß—Ç–æ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å:
‚úÖ **–°–µ—Ä—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –∫—Ä–∏–ø—Ç–æ–∑–∞—â–∏—Ç—ã**
- –¢–æ–ª—å–∫–æ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –∏–∑ –ì–û–°–¢ –† 34.10-2012 (–≠–¶–ü)
- –¢–æ–ª—å–∫–æ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –∏–∑ –ì–û–°–¢ –† 34.11-2012 (—Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –°—Ç—Ä–∏–±–æ–≥)
- –ì–û–°–¢ –† 34.12-2015 (—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –ö—É–∑–Ω–µ—á–∏–∫, –ú–∞–≥–º–∞)
- –ó–∞–ø—Ä–µ—Ç –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–µ—Å–µ—Ä—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ (RSA, ECDSA) –¥–ª—è –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º

‚úÖ **–£—Ä–æ–≤–Ω–∏ –∑–∞—â–∏—â–µ–Ω–Ω–æ—Å—Ç–∏ –ò–°–ü–î–Ω**
- **–£–ó-1** (–≤—ã—Å–æ–∫–∏–π): –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –°–ö–ó–ò, —Å–µ—Ä—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –§–°–ë
- **–£–ó-2** (—Å—Ä–µ–¥–Ω–∏–π): –°–ö–ó–ò + –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ä—ã
- **–£–ó-3** (–±–∞–∑–æ–≤—ã–π): –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
- **–£–ó-4** (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π): —É–ø—Ä–æ—â–µ–Ω–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è

‚úÖ **–ö–≤–∞–Ω—Ç–æ–≤–æ-—É—Å—Ç–æ–π—á–∏–≤–∞—è –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è (—Å 2025)**
- –ì–û–°–¢ –† 34.10-2023 (–∫–≤–∞–Ω—Ç–æ–≤–æ-—É—Å—Ç–æ–π—á–∏–≤–∞—è –≠–¶–ü)
- –ì–∏–±—Ä–∏–¥–Ω—ã–µ —Å—Ö–µ–º—ã (–∫–ª–∞—Å—Å–∏–∫–∞ + PQC)
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –ö–ò–ò (–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞)

##### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ –ø—Ä–æ–µ–∫—Ç–µ:

```python
# backend/app/compliance/fstec.py
class FSTECComplianceChecker:
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –§–°–¢–≠–ö
    """
    
    GOST_ALGORITHMS = {
        'signature': ['GOST R 34.10-2012', 'GOST R 34.10-2023'],
        'hash': ['GOST R 34.11-2012', 'Streebog-256', 'Streebog-512'],
        'cipher': ['GOST R 34.12-2015', 'Kuznyechik', 'Magma']
    }
    
    PROHIBITED_FOR_GOV = [
        'RSA', 'ECDSA', 'SHA-1', 'MD5', 'DES', '3DES', 'RC4'
    ]
    
    def check_uz_level(self, scan_results: dict, target_uz: int) -> dict:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —É—Ä–æ–≤–Ω—é –∑–∞—â–∏—â–µ–Ω–Ω–æ—Å—Ç–∏ –£–ó-1 –¥–æ –£–ó-4
        """
        findings = []
        
        # –£–ó-1: –¢–æ–ª—å–∫–æ –ì–û–°–¢ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
        if target_uz == 1:
            if not self._uses_only_gost(scan_results):
                findings.append({
                    'severity': 'P0',
                    'category': 'fstec_uz1_violation',
                    'description': '–î–ª—è –£–ó-1 —Ä–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ —Å–µ—Ä—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ì–û–°–¢ –∞–ª–≥–æ—Ä–∏—Ç–º—ã',
                    'remediation': '–ó–∞–º–µ–Ω–∏—Ç—å RSA/ECDSA –Ω–∞ –ì–û–°–¢ –† 34.10-2012'
                })
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
        for prohibited in self.PROHIBITED_FOR_GOV:
            if prohibited in scan_results.get('algorithms', []):
                findings.append({
                    'severity': 'P0',
                    'category': 'fstec_prohibited_algo',
                    'description': f'–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ {prohibited} –∑–∞–ø—Ä–µ—â–µ–Ω–æ –¥–ª—è –≥–æ—Å—Å–∏—Å—Ç–µ–º',
                    'regulation': '–§–°–¢–≠–ö –ü—Ä–∏–∫–∞–∑ ‚Ññ17'
                })
        
        return {
            'compliant': len(findings) == 0,
            'uz_level': target_uz,
            'findings': findings
        }
```

##### –ù–æ–≤—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ (–¥–æ–±–∞–≤–∏—Ç—å –≤ scanner.py):

```python
# –ü—Ä–æ–≤–µ—Ä–∫–∞ 1: –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ì–û–°–¢ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
def detect_gost_support(target: str, port: int = 443) -> dict:
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –ì–û–°–¢ TLS cipher suites
    
    –ì–û–°–¢ cipher suites:
    - TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC
    - TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC
    - TLS_GOSTR341112_256_WITH_28147_CNT_IMIT
    """
    gost_ciphers = [
        0xC100,  # GOST 2012-256
        0xC101,  # GOST 2012-512
        0xFF85,  # GOST 28147-89
    ]
    
    # –û—Ç–ø—Ä–∞–≤–∏—Ç—å ClientHello —Å –ì–û–°–¢ cipher suites
    # –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ PQC —Å–∫–∞–Ω–µ—Ä—É, –Ω–æ –¥–ª—è –ì–û–°–¢
    pass

# –ü—Ä–æ–≤–µ—Ä–∫–∞ 2: –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤ –§–°–ë
def verify_fsb_certificate(cert_data: dict) -> dict:
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –≤—ã–¥–∞–Ω –∞–∫–∫—Ä–µ–¥–∏—Ç–æ–≤–∞–Ω–Ω—ã–º –£–¶ –§–°–ë
    """
    accredited_cas = [
        'CN=Russian Trusted Root CA',
        'CN=CryptoPro',
        # –ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∏–∑ —Ä–µ–µ—Å—Ç—Ä–∞ –ú–∏–Ω—Ü–∏—Ñ—Ä—ã
    ]
    
    issuer = cert_data.get('issuer')
    is_accredited = any(ca in issuer for ca in accredited_cas)
    
    return {
        'is_accredited': is_accredited,
        'issuer': issuer,
        'warning': None if is_accredited else '–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –Ω–µ –æ—Ç –∞–∫–∫—Ä–µ–¥–∏—Ç–æ–≤–∞–Ω–Ω–æ–≥–æ –£–¶'
    }
```

#### 1.2. **–§–°–ë –†–æ—Å—Å–∏–∏ (–°–ª—É–∂–±–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)**

##### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –§–°–ë:
- **–ü—Ä–∏–∫–∞–∑ –§–°–ë ‚Ññ378** (2015): –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –°–ö–ó–ò
- **–õ–∏—Ü–µ–Ω–∑–∏—Ä–æ–≤–∞–Ω–∏–µ**: –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –°–ö–ó–ò –∫–ª–∞—Å—Å–∞ –ö–°1, –ö–°2, –ö–°3
- **–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è**: –û–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –¥–ª—è –ö–ò–ò –∏ –≥–æ—Å—Å–∏—Å—Ç–µ–º

##### –ß—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å:
‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç–æ–ª—å–∫–æ –ª–∏—Ü–µ–Ω–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –°–ö–ó–ò  
‚úÖ –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∫–ª–∞—Å—Å—É –∑–∞—â–∏—Ç—ã (–ö–°1-–ö–°3)  
‚úÖ –ê–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –ª–∏—Ü–µ–Ω–∑–∏–π –∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤

##### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è:

```python
# backend/app/compliance/fsb.py
class FSBComplianceChecker:
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –§–°–ë
    """
    
    LICENSED_SKZI = {
        'CryptoPro CSP': {'classes': ['KC1', 'KC2'], 'valid_until': '2026-12-31'},
        'ViPNet': {'classes': ['KC1'], 'valid_until': '2027-06-30'},
        'Signal-COM': {'classes': ['KC2'], 'valid_until': '2025-12-31'},
    }
    
    def check_skzi_license(self, detected_skzi: str) -> dict:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Ü–µ–Ω–∑–∏–∏ –°–ö–ó–ò
        """
        if detected_skzi not in self.LICENSED_SKZI:
            return {
                'compliant': False,
                'error': f'–°–ö–ó–ò {detected_skzi} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ —Ä–µ–µ—Å—Ç—Ä–µ –§–°–ë'
            }
        
        skzi_info = self.LICENSED_SKZI[detected_skzi]
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è –ª–∏—Ü–µ–Ω–∑–∏–∏
        # ...
        
        return {
            'compliant': True,
            'skzi': detected_skzi,
            'classes': skzi_info['classes']
        }
```

#### 1.3. **–ì–û–°–¢ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—ã**

##### –ö–ª—é—á–µ–≤—ã–µ –ì–û–°–¢—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏:
- **–ì–û–°–¢ –† 34.10-2012**: –≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è —Ü–∏—Ñ—Ä–æ–≤–∞—è –ø–æ–¥–ø–∏—Å—å
- **–ì–û–°–¢ –† 34.11-2012**: –•—ç—à-—Ñ—É–Ω–∫—Ü–∏—è –°—Ç—Ä–∏–±–æ–≥
- **–ì–û–°–¢ –† 34.12-2015**: –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ (–ö—É–∑–Ω–µ—á–∏–∫, –ú–∞–≥–º–∞)
- **–ì–û–°–¢ –† 34.13-2015**: –†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã –±–ª–æ—á–Ω—ã—Ö —à–∏—Ñ—Ä–æ–≤
- **–ì–û–°–¢ 28147-89**: –£—Å—Ç–∞—Ä–µ–≤—à–∏–π, –Ω–æ –µ—â–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è

##### –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ì–û–°–¢:

```python
def detect_gost_in_certificate(cert: dict) -> dict:
    """
    –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ì–û–°–¢ –≤ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–µ
    """
    gost_oids = {
        '1.2.643.7.1.1.1.1': 'GOST R 34.10-2012 (256 bit)',
        '1.2.643.7.1.1.1.2': 'GOST R 34.10-2012 (512 bit)',
        '1.2.643.7.1.1.2.2': 'GOST R 34.11-2012 (Streebog 256)',
        '1.2.643.7.1.1.2.3': 'GOST R 34.11-2012 (Streebog 512)',
    }
    
    signature_algorithm = cert.get('signature_algorithm')
    
    for oid, name in gost_oids.items():
        if oid in signature_algorithm:
            return {
                'uses_gost': True,
                'algorithm': name,
                'oid': oid
            }
    
    return {
        'uses_gost': False,
        'warning': '–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ì–û–°–¢ –∞–ª–≥–æ—Ä–∏—Ç–º—ã'
    }
```

### –ù–æ–≤—ã–π –º–æ–¥—É–ª—å: Compliance Score –¥–ª—è –†–§

```python
# backend/app/compliance/rf_score.py
class RFComplianceScore:
    """
    –û—Ü–µ–Ω–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Ä–æ—Å—Å–∏–π—Å–∫–∏–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º (–∞–Ω–∞–ª–æ–≥ PQ-Score)
    
    RF-Score (0-100):
    - 100: –ü–æ–ª–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –ì–û–°–¢/–§–°–¢–≠–ö/–§–°–ë
    - 0: –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Ä—É—à–µ–Ω–∏—è
    """
    
    WEIGHTS = {
        'gost_usage': 0.40,        # 40% - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ì–û–°–¢
        'fstec_compliance': 0.30,  # 30% - —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –§–°–¢–≠–ö
        'fsb_skzi': 0.20,          # 20% - –ª–∏—Ü–µ–Ω–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –°–ö–ó–ò
        'cert_validity': 0.10,     # 10% - –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
    }
    
    def calculate(self, scan_results: dict, target_sector: str) -> dict:
        """
        –†–∞—Å—á–µ—Ç RF-Score
        
        target_sector: 'government', 'finance', 'healthcare', 'commercial'
        """
        scores = {}
        
        # 1. –û—Ü–µ–Ω–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ì–û–°–¢
        gost_score = self._evaluate_gost_usage(scan_results)
        scores['gost_usage'] = gost_score
        
        # 2. –û—Ü–µ–Ω–∫–∞ –§–°–¢–≠–ö (—Ç–æ–ª—å–∫–æ –¥–ª—è –≥–æ—Å—Å–µ–∫—Ç–æ—Ä–∞ –∏ –ö–ò–ò)
        if target_sector in ['government', 'critical_infrastructure']:
            fstec_score = self._evaluate_fstec(scan_results)
        else:
            fstec_score = 1.0  # –ù–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –∫–æ–º–º–µ—Ä—Ü–∏–∏
        scores['fstec_compliance'] = fstec_score
        
        # 3. –û—Ü–µ–Ω–∫–∞ –°–ö–ó–ò
        skzi_score = self._evaluate_skzi(scan_results)
        scores['fsb_skzi'] = skzi_score
        
        # 4. –í–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤
        cert_score = self._evaluate_certificates(scan_results)
        scores['cert_validity'] = cert_score
        
        # –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç
        rf_score = sum(
            scores[key] * self.WEIGHTS[key]
            for key in self.WEIGHTS
        )
        
        return {
            'rf_score': round(rf_score * 100),
            'components': scores,
            'risk_level': self._get_risk_level(rf_score * 100),
            'sector': target_sector
        }
```

### API –∏–∑–º–µ–Ω–µ–Ω–∏—è

```python
# backend/app/schemas.py
class ScanCreate(BaseModel):
    target: str
    scan_type: str = "tls_network"
    project_id: Optional[int] = None
    
    # –ù–æ–≤—ã–µ –ø–æ–ª—è –¥–ª—è –†–§ compliance
    check_rf_compliance: bool = False
    target_sector: str = "commercial"  # government, finance, healthcare, critical_infrastructure
    target_uz_level: Optional[int] = None  # 1-4 –¥–ª—è –§–°–¢–≠–ö

# backend/app/main.py
@app.post("/api/scans", response_model=ScanResponse)
async def create_scan(
    scan: ScanCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    # ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ ...
    
    # –î–æ–±–∞–≤–∏—Ç—å RF compliance –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å–∫–∞–Ω–∞
    if scan.check_rf_compliance:
        scan_record.metadata = {
            'rf_compliance': True,
            'target_sector': scan.target_sector,
            'uz_level': scan.target_uz_level
        }
```

### PDF –æ—Ç—á–µ—Ç —Å RF compliance

```python
# backend/app/report_generator.py
def generate_rf_compliance_section(rf_score_data: dict) -> str:
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–µ–∫—Ü–∏–∏ —Å RF compliance –¥–ª—è PDF
    """
    template = """
    <div class="rf-compliance">
        <h2>üá∑üá∫ –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –†–§</h2>
        
        <div class="rf-score">
            <h3>RF-Score: {{ rf_score }}/100</h3>
            <div class="risk-level {{ risk_level }}">
                –£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: {{ risk_level }}
            </div>
        </div>
        
        <div class="compliance-details">
            <h4>–ì–û–°–¢ –∞–ª–≥–æ—Ä–∏—Ç–º—ã</h4>
            {% if gost_detected %}
                <p class="success">‚úÖ –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ì–û–°–¢</p>
                <ul>
                {% for algo in gost_algorithms %}
                    <li>{{ algo }}</li>
                {% endfor %}
                </ul>
            {% else %}
                <p class="warning">‚ö†Ô∏è –ì–û–°–¢ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã</p>
            {% endif %}
            
            <h4>–§–°–¢–≠–ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ</h4>
            {% if fstec_compliant %}
                <p class="success">‚úÖ –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –§–°–¢–≠–ö</p>
            {% else %}
                <p class="error">‚ùå –ù–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –§–°–¢–≠–ö</p>
                <ul>
                {% for violation in fstec_violations %}
                    <li>{{ violation }}</li>
                {% endfor %}
                </ul>
            {% endif %}
        </div>
        
        <div class="recommendations">
            <h4>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—é</h4>
            <ol>
                <li>–í–Ω–µ–¥—Ä–∏—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –°–ö–ó–ò (CryptoPro CSP, ViPNet)</li>
                <li>–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ –ì–û–°–¢ –† 34.10-2012 –¥–ª—è –≠–¶–ü</li>
                <li>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –°—Ç—Ä–∏–±–æ–≥ (–ì–û–°–¢ –† 34.11-2012) –≤–º–µ—Å—Ç–æ SHA-256</li>
                <li>–ü–æ–ª—É—á–∏—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –§–°–ë –¥–ª—è –°–ö–ó–ò</li>
            </ol>
        </div>
    </div>
    """
    # –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Å Jinja2
```

---

## üîê –ß–∞—Å—Ç—å 2: –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –Ω–∞ –∫—Ä–∏–ø—Ç–æ–∞–∫—Ç–∏–≤—ã (—Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏, SBOM, –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã)

### –¢–µ–∫—É—â–∞—è —Å–∏—Ç—É–∞—Ü–∏—è
–°–∫–∞–Ω–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å –¥–æ–º–µ–Ω–∞–º–∏/IP –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç TLS. –ù—É–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –Ω–∞:
- Git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
- Docker –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã
- –ë–∏–Ω–∞—Ä–Ω—ã–µ —Ñ–∞–π–ª—ã
- SBOM (Software Bill of Materials)

### 2.1. **–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤**

#### –ß—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è—Ö:
‚úÖ –•–∞—Ä–¥–∫–æ–∂–µ–Ω–Ω—ã–µ –∫–ª—é—á–∏ –∏ —Å–µ–∫—Ä–µ—Ç—ã  
‚úÖ –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ –∫—Ä–∏–ø—Ç–æ–±–∏–±–ª–∏–æ—Ç–µ–∫–∏  
‚úÖ –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫—Ä–∏–ø—Ç–æ-API  
‚úÖ –°–ª–∞–±—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –≤ –∫–æ–¥–µ  

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è:

```python
# backend/app/scanners/repository_scanner.py
class RepositoryScanner:
    """
    –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤ –Ω–∞ –∫—Ä–∏–ø—Ç–æ—É—è–∑–≤–∏–º–æ—Å—Ç–∏
    """
    
    def __init__(self):
        self.secret_patterns = [
            r'-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----',
            r'sk-[a-zA-Z0-9]{32,}',  # Stripe secret keys
            r'ghp_[a-zA-Z0-9]{36}',  # GitHub tokens
            r'AKIA[0-9A-Z]{16}',     # AWS access keys
        ]
        
        self.crypto_patterns = {
            'weak_hash': [
                r'hashlib\.md5\(',
                r'hashlib\.sha1\(',
                r'MD5\.',
                r'SHA1\.',
            ],
            'weak_cipher': [
                r'DES\.',
                r'RC4\.',
                r'Blowfish\.',
            ],
            'hardcoded_keys': [
                r'password\s*=\s*["\'][^"\']+["\']',
                r'api_key\s*=\s*["\'][^"\']+["\']',
            ]
        }
    
    async def scan_repository(self, repo_url: str, branch: str = 'main') -> dict:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
        """
        findings = []
        
        # 1. –ö–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π (shallow clone)
        repo_path = await self._clone_repo(repo_url, branch)
        
        # 2. –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª—ã
        for file_path in self._get_code_files(repo_path):
            file_findings = await self._scan_file(file_path)
            findings.extend(file_findings)
        
        # 3. –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
        dependency_findings = await self._scan_dependencies(repo_path)
        findings.extend(dependency_findings)
        
        # 4. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –∫–æ–º–º–∏—Ç–æ–≤ (—Å–µ–∫—Ä–µ—Ç—ã –≤ —Å—Ç–∞—Ä—ã—Ö –∫–æ–º–º–∏—Ç–∞—Ö)
        history_findings = await self._scan_git_history(repo_path)
        findings.extend(history_findings)
        
        # 5. –û—á–∏—Å—Ç–∫–∞
        await self._cleanup(repo_path)
        
        return {
            'repository': repo_url,
            'branch': branch,
            'total_findings': len(findings),
            'findings': findings,
            'crypto_score': self._calculate_crypto_score(findings)
        }
    
    async def _scan_file(self, file_path: str) -> List[dict]:
        """
        –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
        """
        findings = []
        
        with open(file_path, 'r', errors='ignore') as f:
            content = f.read()
            line_number = 0
            
            for line in content.split('\n'):
                line_number += 1
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–µ–∫—Ä–µ—Ç—ã
                for pattern in self.secret_patterns:
                    if re.search(pattern, line):
                        findings.append({
                            'type': 'hardcoded_secret',
                            'severity': 'P0',
                            'file': file_path,
                            'line': line_number,
                            'description': '–û–±–Ω–∞—Ä—É–∂–µ–Ω —Ö–∞—Ä–¥–∫–æ–∂–µ–Ω–Ω—ã–π —Å–µ–∫—Ä–µ—Ç/–∫–ª—é—á'
                        })
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∞–±—ã–µ —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏–∏
                for pattern in self.crypto_patterns['weak_hash']:
                    if re.search(pattern, line):
                        findings.append({
                            'type': 'weak_cryptography',
                            'severity': 'P1',
                            'file': file_path,
                            'line': line_number,
                            'description': '–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–ª–∞–±–æ–π —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏–∏ (MD5/SHA1)'
                        })
        
        return findings
    
    async def _scan_dependencies(self, repo_path: str) -> List[dict]:
        """
        –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (requirements.txt, package.json, go.mod)
        """
        findings = []
        
        # Python dependencies
        req_file = os.path.join(repo_path, 'requirements.txt')
        if os.path.exists(req_file):
            findings.extend(await self._check_python_deps(req_file))
        
        # Node.js dependencies
        package_file = os.path.join(repo_path, 'package.json')
        if os.path.exists(package_file):
            findings.extend(await self._check_node_deps(package_file))
        
        # Go dependencies
        go_mod = os.path.join(repo_path, 'go.mod')
        if os.path.exists(go_mod):
            findings.extend(await self._check_go_deps(go_mod))
        
        return findings
    
    async def _check_python_deps(self, req_file: str) -> List[dict]:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ Python –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
        """
        findings = []
        
        # –£—Å—Ç–∞—Ä–µ–≤—à–∏–µ/—É—è–∑–≤–∏–º—ã–µ –∫—Ä–∏–ø—Ç–æ-–±–∏–±–ª–∏–æ—Ç–µ–∫–∏
        vulnerable_packages = {
            'pycrypto': 'Deprecated, use pycryptodome instead',
            'pyDes': 'Weak encryption (DES)',
            'cryptography<3.0': 'Outdated cryptography version',
        }
        
        with open(req_file, 'r') as f:
            for line in f:
                package = line.strip().split('==')[0]
                
                if package in vulnerable_packages:
                    findings.append({
                        'type': 'vulnerable_dependency',
                        'severity': 'P1',
                        'package': package,
                        'description': vulnerable_packages[package]
                    })
        
        return findings
```

#### API –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤:

```python
# backend/app/schemas.py
class RepositoryScanCreate(BaseModel):
    repository_url: str  # https://github.com/user/repo
    branch: str = "main"
    project_id: Optional[int] = None
    scan_credentials: Optional[dict] = None  # –î–ª—è –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö —Ä–µ–ø–æ

# backend/app/main.py
@app.post("/api/scans/repository", response_model=ScanResponse)
async def scan_repository(
    scan: RepositoryScanCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
    """
    # –°–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å —Å–∫–∞–Ω–∞
    scan_record = Scan(
        target=scan.repository_url,
        scan_type="repository",
        status=ScanStatus.PENDING,
        user_id=current_user.id,
        project_id=scan.project_id
    )
    db.add(scan_record)
    db.commit()
    
    # –ó–∞–ø—É—Å—Ç–∏—Ç—å Celery task
    task = repository_scan_task.delay(
        scan_id=scan_record.id,
        repo_url=scan.repository_url,
        branch=scan.branch
    )
    
    return scan_record
```

### 2.2. **SBOM (Software Bill of Materials) –∞–Ω–∞–ª–∏–∑**

#### –ß—Ç–æ —Ç–∞–∫–æ–µ SBOM:
- –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –≤ –ü–û
- –§–æ—Ä–º–∞—Ç—ã: CycloneDX, SPDX, SWID
- –û–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –≥–æ—Å–∑–∞–∫—É–ø–æ–∫ –≤ –°–®–ê (Executive Order 14028)

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è:

```python
# backend/app/scanners/sbom_scanner.py
class SBOMScanner:
    """
    –ê–Ω–∞–ª–∏–∑ SBOM –Ω–∞ –∫—Ä–∏–ø—Ç–æ—É—è–∑–≤–∏–º–æ—Å—Ç–∏
    """
    
    def __init__(self):
        # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
        self.vuln_db = self._load_vulnerability_database()
    
    async def analyze_sbom(self, sbom_file: str, format: str = 'cyclonedx') -> dict:
        """
        –ê–Ω–∞–ª–∏–∑ SBOM —Ñ–∞–π–ª–∞
        
        format: 'cyclonedx', 'spdx', 'swid'
        """
        # 1. –ü–∞—Ä—Å–∏–Ω–≥ SBOM
        components = self._parse_sbom(sbom_file, format)
        
        findings = []
        
        # 2. –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —É—è–∑–≤–∏–º–æ—Å—Ç–∏
        for component in components:
            vulns = await self._check_vulnerabilities(
                name=component['name'],
                version=component['version']
            )
            
            for vuln in vulns:
                findings.append({
                    'component': component['name'],
                    'version': component['version'],
                    'vulnerability': vuln['id'],  # CVE-2023-XXXX
                    'severity': vuln['severity'],
                    'description': vuln['description'],
                    'remediation': vuln['fixed_in']
                })
        
        # 3. –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏–ø—Ç–æ–±–∏–±–ª–∏–æ—Ç–µ–∫
        crypto_findings = self._check_crypto_libraries(components)
        findings.extend(crypto_findings)
        
        return {
            'total_components': len(components),
            'vulnerable_components': len(set(f['component'] for f in findings)),
            'findings': findings,
            'crypto_score': self._calculate_crypto_score(findings)
        }
    
    def _check_crypto_libraries(self, components: List[dict]) -> List[dict]:
        """
        –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫
        """
        crypto_libraries = {
            'openssl': {
                'min_version': '1.1.1',
                'recommended': '3.0.0',
                'vulnerabilities': ['CVE-2022-0778', 'Heartbleed']
            },
            'cryptography': {
                'min_version': '3.0',
                'recommended': '41.0',
            },
            'pycrypto': {
                'status': 'deprecated',
                'replacement': 'pycryptodome'
            }
        }
        
        findings = []
        
        for component in components:
            name = component['name'].lower()
            version = component['version']
            
            if name in crypto_libraries:
                lib_info = crypto_libraries[name]
                
                if lib_info.get('status') == 'deprecated':
                    findings.append({
                        'type': 'deprecated_crypto_library',
                        'severity': 'P0',
                        'component': name,
                        'description': f'{name} —É—Å—Ç–∞—Ä–µ–ª–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ {lib_info["replacement"]}'
                    })
                
                elif version < lib_info['min_version']:
                    findings.append({
                        'type': 'outdated_crypto_library',
                        'severity': 'P1',
                        'component': name,
                        'version': version,
                        'description': f'–í–µ—Ä—Å–∏—è {version} —É—Å—Ç–∞—Ä–µ–ª–∞, –æ–±–Ω–æ–≤–∏—Ç–µ –¥–æ {lib_info["recommended"]}'
                    })
        
        return findings
```

### 2.3. **–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Docker –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤**

```python
# backend/app/scanners/container_scanner.py
class ContainerScanner:
    """
    –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Docker –æ–±—Ä–∞–∑–æ–≤ –Ω–∞ –∫—Ä–∏–ø—Ç–æ—É—è–∑–≤–∏–º–æ—Å—Ç–∏
    """
    
    async def scan_container(self, image: str) -> dict:
        """
        –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Docker –æ–±—Ä–∞–∑–∞
        
        image: 'nginx:latest', 'myregistry.com/myapp:v1.0'
        """
        findings = []
        
        # 1. –ò–∑–≤–ª–µ—á—å SBOM –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        sbom = await self._extract_sbom(image)
        if sbom:
            sbom_findings = await SBOMScanner().analyze_sbom(sbom)
            findings.extend(sbom_findings['findings'])
        
        # 2. –°–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –ø–∞–∫–µ—Ç—ã
        packages = await self._get_installed_packages(image)
        for package in packages:
            vulns = await self._check_package_vulnerabilities(package)
            findings.extend(vulns)
        
        # 3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é TLS/SSL –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
        tls_config = await self._check_tls_config(image)
        if tls_config['issues']:
            findings.extend(tls_config['issues'])
        
        # 4. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ
        certs = await self._find_certificates(image)
        for cert in certs:
            cert_findings = await self._analyze_certificate(cert)
            findings.extend(cert_findings)
        
        return {
            'image': image,
            'total_findings': len(findings),
            'findings': findings,
            'container_score': self._calculate_container_score(findings)
        }
```

### 2.4. **Unified Scan API (–≤—Å–µ —Ç–∏–ø—ã –∞–∫—Ç–∏–≤–æ–≤)**

```python
# backend/app/schemas.py
class UnifiedScanCreate(BaseModel):
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ API –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ª—é–±—ã—Ö –∞–∫—Ç–∏–≤–æ–≤
    """
    target: str
    scan_type: str  # 'domain', 'repository', 'container', 'sbom', 'binary'
    project_id: Optional[int] = None
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
    options: Optional[dict] = None
    
    # –î–ª—è —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–µ–≤
    # options = {'branch': 'main', 'credentials': {...}}
    
    # –î–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤
    # options = {'registry_auth': {...}}
    
    # –î–ª—è SBOM
    # options = {'format': 'cyclonedx'}

# backend/app/main.py
@app.post("/api/scans/unified", response_model=ScanResponse)
async def create_unified_scan(
    scan: UnifiedScanCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ API –¥–ª—è –ª—é–±—ã—Ö —Ç–∏–ø–æ–≤ —Å–∫–∞–Ω–æ–≤
    """
    # –†–æ—É—Ç–∏–Ω–≥ –Ω–∞ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–∫–∞–Ω–µ—Ä—ã
    scanner_map = {
        'domain': domain_scan_task,
        'repository': repository_scan_task,
        'container': container_scan_task,
        'sbom': sbom_scan_task,
    }
    
    task_func = scanner_map.get(scan.scan_type)
    if not task_func:
        raise HTTPException(400, f"Unknown scan type: {scan.scan_type}")
    
    # –°–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å
    scan_record = Scan(
        target=scan.target,
        scan_type=scan.scan_type,
        status=ScanStatus.PENDING,
        user_id=current_user.id,
        project_id=scan.project_id
    )
    db.add(scan_record)
    db.commit()
    
    # –ó–∞–ø—É—Å—Ç–∏—Ç—å task
    task = task_func.delay(
        scan_id=scan_record.id,
        target=scan.target,
        options=scan.options or {}
    )
    
    return scan_record
```

---

## üíº –ß–∞—Å—Ç—å 3: –†–∞–∑–≤–∏—Ç–∏–µ –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∏ –ø—Ä–æ–¥—É–∫—Ç–∞

### 3.1. **–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è –∏ –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ü–∏—è**

#### Continuous Security Monitoring

```python
# backend/app/automation/scheduler.py
class ContinuousMonitoring:
    """
    –ù–µ–ø—Ä–µ—Ä—ã–≤–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    """
    
    async def setup_monitoring(
        self,
        project_id: int,
        targets: List[str],
        frequency: str = 'daily',  # hourly, daily, weekly, monthly
        alert_channels: List[str] = None
    ):
        """
        –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        """
        # 1. –°–æ–∑–¥–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤ Celery Beat
        schedule = {
            'task': 'app.tasks.automated_scan',
            'schedule': self._get_schedule(frequency),
            'args': (project_id, targets),
        }
        
        # 2. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å –∞–ª–µ—Ä—Ç—ã
        if alert_channels:
            self._setup_alerts(project_id, alert_channels)
        
        return schedule
    
    def _get_schedule(self, frequency: str):
        """
        –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ frequency –≤ Celery schedule
        """
        schedules = {
            'hourly': crontab(minute=0),
            'daily': crontab(hour=2, minute=0),  # 2 AM
            'weekly': crontab(hour=2, minute=0, day_of_week=1),  # Monday
            'monthly': crontab(hour=2, minute=0, day_of_month=1),
        }
        return schedules.get(frequency, schedules['daily'])
```

#### Policy Engine (–ø–æ–ª–∏—Ç–∏–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)

```python
# backend/app/automation/policy_engine.py
class PolicyEngine:
    """
    –î–≤–∏–∂–æ–∫ –ø–æ–ª–∏—Ç–∏–∫ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    """
    
    def __init__(self):
        self.policies = []
    
    def add_policy(self, policy: dict):
        """
        –î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª–∏—Ç–∏–∫—É –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        
        –ü—Ä–∏–º–µ—Ä –ø–æ–ª–∏—Ç–∏–∫–∏:
        {
            'name': 'Block weak TLS',
            'condition': 'pq_score > 60',
            'action': 'block_deployment',
            'notify': ['security@company.com']
        }
        """
        self.policies.append(policy)
    
    async def evaluate(self, scan_results: dict) -> dict:
        """
        –û—Ü–µ–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∞ –ø–æ –≤—Å–µ–º –ø–æ–ª–∏—Ç–∏–∫–∞–º
        """
        violations = []
        actions = []
        
        for policy in self.policies:
            if self._evaluate_condition(policy['condition'], scan_results):
                violations.append(policy['name'])
                actions.append(policy['action'])
                
                # –í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ
                await self._execute_action(policy, scan_results)
        
        return {
            'violations': violations,
            'actions_taken': actions,
            'compliant': len(violations) == 0
        }
    
    def _evaluate_condition(self, condition: str, scan_results: dict) -> bool:
        """
        –û—Ü–µ–Ω–∏—Ç—å —É—Å–ª–æ–≤–∏–µ (–ø—Ä–æ—Å—Ç–æ–π DSL)
        """
        # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π
        allowed_vars = {
            'pq_score': scan_results.get('pq_score', 0),
            'rf_score': scan_results.get('rf_score', 0),
            'findings_count': len(scan_results.get('findings', [])),
        }
        
        try:
            return eval(condition, {"__builtins__": {}}, allowed_vars)
        except:
            return False
    
    async def _execute_action(self, policy: dict, scan_results: dict):
        """
        –í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –ø–æ –ø–æ–ª–∏—Ç–∏–∫–µ
        """
        action = policy['action']
        
        if action == 'block_deployment':
            # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å CI/CD –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–µ–ø–ª–æ—è
            await self._block_ci_cd(scan_results)
        
        elif action == 'notify':
            # –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            await self._send_notifications(
                recipients=policy['notify'],
                scan_results=scan_results
            )
        
        elif action == 'create_ticket':
            # –°–æ–∑–¥–∞—Ç—å —Ç–∏–∫–µ—Ç –≤ Jira/ServiceNow
            await self._create_ticket(scan_results)
```

### 3.2. **–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –∏ BI**

#### Trending –∏ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑

```python
# backend/app/analytics/trends.py
class SecurityTrends:
    """
    –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    """
    
    async def get_trend_analysis(
        self,
        project_id: int,
        timeframe: str = '30d'  # 7d, 30d, 90d, 1y
    ) -> dict:
        """
        –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–æ–≤ –∑–∞ –ø–µ—Ä–∏–æ–¥
        """
        scans = await self._get_historical_scans(project_id, timeframe)
        
        return {
            'pq_score_trend': self._calculate_trend([s.pq_score for s in scans]),
            'findings_trend': self._calculate_trend([len(s.findings) for s in scans]),
            'risk_level_changes': self._analyze_risk_changes(scans),
            'top_vulnerabilities': self._get_top_vulnerabilities(scans),
            'remediation_velocity': self._calculate_remediation_velocity(scans),
        }
    
    def _calculate_trend(self, values: List[float]) -> dict:
        """
        –†–∞—Å—á–µ—Ç —Ç—Ä–µ–Ω–¥–∞ (—Ä–∞—Å—Ç–µ—Ç/–ø–∞–¥–∞–µ—Ç/—Å—Ç–∞–±–∏–ª—å–Ω–æ)
        """
        if len(values) < 2:
            return {'trend': 'insufficient_data'}
        
        # –õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è
        slope = self._linear_regression(values)
        
        if slope > 0.1:
            direction = 'improving'
        elif slope < -0.1:
            direction = 'deteriorating'
        else:
            direction = 'stable'
        
        return {
            'trend': direction,
            'slope': slope,
            'values': values
        }
```

#### Dashboard API

```python
# backend/app/main.py
@app.get("/api/analytics/dashboard")
async def get_security_dashboard(
    project_id: Optional[int] = None,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Unified security dashboard
    """
    # 1. –¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å
    current_status = await get_current_security_status(project_id, db)
    
    # 2. –¢—Ä–µ–Ω–¥—ã
    trends = await SecurityTrends().get_trend_analysis(project_id)
    
    # 3. Top –ø—Ä–æ–±–ª–µ–º—ã
    top_issues = await get_top_security_issues(project_id, db)
    
    # 4. Compliance —Å—Ç–∞—Ç—É—Å
    compliance = await get_compliance_status(project_id, db)
    
    return {
        'status': current_status,
        'trends': trends,
        'top_issues': top_issues,
        'compliance': compliance,
        'generated_at': datetime.now().isoformat()
    }
```

### 3.3. **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏**

#### CI/CD –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è

```python
# backend/app/integrations/cicd.py
class CICDIntegration:
    """
    –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å CI/CD –ø–∞–π–ø–ª–∞–π–Ω–∞–º–∏
    """
    
    async def gitlab_integration(self, project_id: int, gitlab_token: str):
        """
        GitLab CI/CD –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
        """
        # .gitlab-ci.yml snippet –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
        ci_config = """
security_scan:
  stage: test
  script:
    - |
      SCAN_RESULT=$(curl -X POST https://scanner.example.com/api/scans/unified \
        -H "Authorization: ******" \
        -H "Content-Type: application/json" \
        -d '{
          "target": "$CI_REPOSITORY_URL",
          "scan_type": "repository",
          "options": {"branch": "$CI_COMMIT_REF_NAME"}
        }' | jq -r '.id')
      
      # –î–æ–∂–¥–∞—Ç—å—Å—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
      while true; do
        STATUS=$(curl -H "Authorization: ******" \
          https://scanner.example.com/api/scans/$SCAN_RESULT/status | jq -r '.status')
        
        if [ "$STATUS" = "done" ]; then
          break
        fi
        sleep 10
      done
      
      # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      SCORE=$(curl -H "Authorization: ******" \
        https://scanner.example.com/api/scans/$SCAN_RESULT/result | jq -r '.pq_score')
      
      if [ "$SCORE" -gt 60 ]; then
        echo "Security scan failed: PQ-Score = $SCORE"
        exit 1
      fi
  only:
    - merge_requests
"""
        return ci_config
    
    async def github_actions_integration(self):
        """
        GitHub Actions –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
        """
        workflow = """
name: Security Scan

on:
  pull_request:
    branches: [ main ]

jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Crypto Scanner
        uses: maxim290905/crypto-scanner-action@v1
        with:
          api_url: ${{ secrets.SCANNER_API_URL }}
          api_token: ${{ secrets.SCANNER_TOKEN }}
          fail_on_score: 60
"""
        return workflow
```

#### Ticket system integration

```python
# backend/app/integrations/ticketing.py
class TicketingIntegration:
    """
    –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å–∏—Å—Ç–µ–º–∞–º–∏ —Ç–∏–∫–µ—Ç–æ–≤ (Jira, ServiceNow)
    """
    
    async def create_jira_ticket(self, finding: dict, jira_config: dict):
        """
        –°–æ–∑–¥–∞—Ç—å —Ç–∏–∫–µ—Ç –≤ Jira –¥–ª—è finding
        """
        jira = JIRA(
            server=jira_config['server'],
            basic_auth=(jira_config['username'], jira_config['api_token'])
        )
        
        issue_dict = {
            'project': {'key': jira_config['project_key']},
            'summary': f"[Security] {finding['category']} - {finding['title']}",
            'description': self._format_finding_for_jira(finding),
            'issuetype': {'name': 'Bug'},
            'priority': {'name': self._map_severity_to_priority(finding['severity'])},
            'labels': ['security', 'crypto', 'automated'],
        }
        
        new_issue = jira.create_issue(fields=issue_dict)
        return new_issue.key
    
    def _format_finding_for_jira(self, finding: dict) -> str:
        """
        –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å finding –¥–ª—è Jira
        """
        return f"""
h2. –î–µ—Ç–∞–ª–∏ —É—è–∑–≤–∏–º–æ—Å—Ç–∏

*–ö–∞—Ç–µ–≥–æ—Ä–∏—è:* {finding['category']}
*–°–µ—Ä—å–µ–∑–Ω–æ—Å—Ç—å:* {finding['severity']}
*–¶–µ–ª–µ–≤–æ–π —Ö–æ—Å—Ç:* {finding['target']}

h3. –û–ø–∏—Å–∞–Ω–∏–µ
{finding['description']}

h3. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—é
{finding['remediation']}

h3. –°—Å—ã–ª–∫–∏
* [–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–∫–∞–Ω–∞|{finding['scan_url']}]
* [–î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è|{finding['doc_url']}]
"""
```

### 3.4. **Machine Learning –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π**

```python
# backend/app/ml/predictor.py
class SecurityPredictor:
    """
    ML-–º–æ–¥–µ–ª—å –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –±—É–¥—É—â–∏—Ö –ø—Ä–æ–±–ª–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    """
    
    def __init__(self):
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å
        self.model = self._load_model()
    
    async def predict_future_score(
        self,
        project_id: int,
        days_ahead: int = 30
    ) -> dict:
        """
        –ü—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å PQ-Score —á–µ—Ä–µ–∑ N –¥–Ω–µ–π
        """
        # –ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
        historical_data = await self._get_historical_data(project_id)
        
        # –≠–∫—Å—Ç—Ä–∞–∫—Ü–∏—è –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
        features = self._extract_features(historical_data)
        
        # –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ
        predicted_score = self.model.predict(features)
        
        return {
            'current_score': historical_data[-1]['pq_score'],
            'predicted_score': predicted_score,
            'days_ahead': days_ahead,
            'confidence': 0.85,
            'trend': 'improving' if predicted_score < historical_data[-1]['pq_score'] else 'deteriorating'
        }
    
    async def recommend_actions(self, project_id: int) -> List[dict]:
        """
        –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞—Ç—å –¥–µ–π—Å—Ç–≤–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ ML
        """
        # –ê–Ω–∞–ª–∏–∑ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –≤ —É—Å–ø–µ—à–Ω—ã—Ö –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è—Ö
        successful_remediations = await self._get_successful_remediations()
        
        # –¢–µ–∫—É—â–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –ø—Ä–æ–µ–∫—Ç–∞
        current_issues = await self._get_current_issues(project_id)
        
        # ML —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        recommendations = self.model.recommend(
            current_issues,
            successful_remediations
        )
        
        return recommendations
```

---

## üó∫Ô∏è Implementation Roadmap

### Phase 1: RF Compliance (Q1 2025)
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –í–´–°–û–ö–ò–ô**

- [ ] –ú–æ–¥—É–ª—å –ì–û–°–¢ –¥–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (4 –Ω–µ–¥–µ–ª–∏)
  - GOST R 34.10-2012 detection
  - GOST R 34.11-2012 detection
  - GOST cipher suites –≤ TLS
- [ ] –§–°–¢–≠–ö compliance checker (3 –Ω–µ–¥–µ–ª–∏)
  - –£–ó-1 –¥–æ –£–ó-4 –ø—Ä–æ–≤–µ—Ä–∫–∏
  - –ó–∞–ø—Ä–µ—â–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- [ ] RF-Score calculation (2 –Ω–µ–¥–µ–ª–∏)
- [ ] PDF –æ—Ç—á–µ—Ç—ã —Å RF compliance (2 –Ω–µ–¥–µ–ª–∏)

**–ò—Ç–æ–≥–æ:** 11 –Ω–µ–¥–µ–ª—å, 2.5 –º–µ—Å—è—Ü–∞

### Phase 2: Repository Scanning (Q2 2025)
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –í–´–°–û–ö–ò–ô**

- [ ] Git repository scanner (4 –Ω–µ–¥–µ–ª–∏)
  - Secret detection
  - Weak crypto patterns
  - Dependency scanning
- [ ] SBOM analysis (3 –Ω–µ–¥–µ–ª–∏)
  - CycloneDX parser
  - SPDX parser
  - Vulnerability matching
- [ ] Container scanning (4 –Ω–µ–¥–µ–ª–∏)
  - Docker image analysis
  - Package vulnerability scan

**–ò—Ç–æ–≥–æ:** 11 –Ω–µ–¥–µ–ª—å, 2.5 –º–µ—Å—è—Ü–∞

### Phase 3: Business Logic (Q3 2025)
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –°–†–ï–î–ù–ò–ô**

- [ ] Continuous monitoring (3 –Ω–µ–¥–µ–ª–∏)
  - Celery Beat scheduling
  - Auto-rescanning
- [ ] Policy engine (4 –Ω–µ–¥–µ–ª–∏)
  - DSL –¥–ª—è –ø–æ–ª–∏—Ç–∏–∫
  - Action execution
- [ ] Analytics dashboard (4 –Ω–µ–¥–µ–ª–∏)
  - Trend analysis
  - Historical data
  - ML predictions
- [ ] CI/CD integrations (3 –Ω–µ–¥–µ–ª–∏)
  - GitLab CI
  - GitHub Actions
  - Jenkins plugin

**–ò—Ç–æ–≥–æ:** 14 –Ω–µ–¥–µ–ª—å, 3.5 –º–µ—Å—è—Ü–∞

### Phase 4: Advanced Features (Q4 2025)
**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –ù–ò–ó–ö–ò–ô**

- [ ] ML predictor (6 –Ω–µ–¥–µ–ª—å)
- [ ] Jira/ServiceNow integration (2 –Ω–µ–¥–µ–ª–∏)
- [ ] White-label customization (4 –Ω–µ–¥–µ–ª–∏)
- [ ] Multi-tenancy (4 –Ω–µ–¥–µ–ª–∏)

**–ò—Ç–æ–≥–æ:** 16 –Ω–µ–¥–µ–ª—å, 4 –º–µ—Å—è—Ü–∞

---

## üí∞ –ë–∏–∑–Ω–µ—Å-—ç—Ñ—Ñ–µ–∫—Ç—ã –æ—Ç —Ä–∞–∑–≤–∏—Ç–∏—è

### –ü–æ—Å–ª–µ Phase 1 (RF Compliance):
- ‚úÖ –í—ã—Ö–æ–¥ –Ω–∞ —Ä—ã–Ω–æ–∫ –≥–æ—Å–∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ –†–§ (+5M‚ÇΩ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª)
- ‚úÖ –§–∏–Ω—Ç–µ—Ö –∏ –º–µ–¥—Ç–µ—Ö —Å–µ–∫—Ç–æ—Ä (+$200k ARR)
- ‚úÖ –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Å RF compliance

### –ü–æ—Å–ª–µ Phase 2 (Repository Scanning):
- ‚úÖ DevSecOps —Ä—ã–Ω–æ–∫ (+$500k ARR)
- ‚úÖ –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ TAM (Total Addressable Market) –≤ 3x
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ CI/CD –ø–∞–π–ø–ª–∞–π–Ω—ã

### –ü–æ—Å–ª–µ Phase 3 (Business Logic):
- ‚úÖ Enterprise features ‚Üí –ø–æ–≤—ã—à–µ–Ω–∏–µ ARPU –Ω–∞ 150%
- ‚úÖ –°–Ω–∏–∂–µ–Ω–∏–µ churn rate –Ω–∞ 40% (–∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è)
- ‚úÖ Upsell –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤

### –ü–æ—Å–ª–µ Phase 4 (Advanced):
- ‚úÖ Premium tier pricing (+$100k per customer)
- ‚úÖ White-label –ø–∞—Ä—Ç–Ω–µ—Ä—Å—Ç–≤–∞ (+$1M ARR)
- ‚úÖ ML competitive moat

---

## üìä KPI –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞

### Product KPIs:
- **Scan types supported**: 1 ‚Üí 5 (domain, repo, container, sbom, binary)
- **RF compliance coverage**: 0% ‚Üí 100%
- **Average scan time**: < 5 min per asset
- **False positive rate**: < 5%

### Business KPIs:
- **ARR growth**: $200k ‚Üí $2M (Q1-Q4 2025)
- **Customer acquisition**: 5 ‚Üí 50 paying customers
- **Market share**: 0% ‚Üí 5% (Russian PQC market)
- **NPS score**: > 50

### Technical KPIs:
- **API uptime**: > 99.5%
- **Scan success rate**: > 95%
- **Code coverage**: > 80%
- **Security vulnerabilities**: 0 critical, < 5 high

---

## üéØ –í—ã–≤–æ–¥—ã –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

### –ì–ª–∞–≤–Ω—ã–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã:

1. **RF Compliance (Q1)** - –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Ä–æ—Å—Å–∏–π—Å–∫–æ–≥–æ —Ä—ã–Ω–∫–∞
   - –ì–æ—Å–∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã —Ç—Ä–µ–±—É—é—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –§–°–¢–≠–ö/–§–°–ë
   - –ë—ã—Å—Ç—Ä–∞—è –æ–∫—É–ø–∞–µ–º–æ—Å—Ç—å —á–µ—Ä–µ–∑ –∫—Ä—É–ø–Ω—ã–µ –∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã

2. **Repository Scanning (Q2)** - —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ TAM
   - DevSecOps —Ä—ã–Ω–æ–∫ –æ–≥—Ä–æ–º–µ–Ω ($15B+)
   - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏

3. **Business Logic (Q3)** - —É–≤–µ–ª–∏—á–µ–Ω–∏–µ retention
   - –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è —Å–Ω–∏–∂–∞–µ—Ç churn
   - Enterprise features –ø–æ–≤—ã—à–∞—é—Ç ARPU

4. **Advanced Features (Q4)** - –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ã–π –±–∞—Ä—å–µ—Ä
   - ML —Å–æ–∑–¥–∞–µ—Ç —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π moat
   - White-label –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç B2B2C –∫–∞–Ω–∞–ª

### –†–µ—Å—É—Ä—Å—ã:
- **–ö–æ–º–∞–Ω–¥–∞**: 3-4 —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –Ω–∞ 12 –º–µ—Å—è—Ü–µ–≤
- **–ë—é–¥–∂–µ—Ç**: $300k-400k (–∑–∞—Ä–ø–ª–∞—Ç—ã + –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞)
- **ROI**: $2M+ ARR –∫ –∫–æ–Ω—Ü—É 2025 = 5-7x ROI

### –†–∏—Å–∫–∏:
- ‚ö†Ô∏è –°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –§–°–¢–≠–ö –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 6+ –º–µ—Å—è—Ü–µ–≤
- ‚ö†Ô∏è –°–ª–æ–∂–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –ì–û–°–¢ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏–µ–π
- ‚ö†Ô∏è –ö–æ–Ω–∫—É—Ä–µ–Ω—Ü–∏—è —Å –∑–∞–ø–∞–¥–Ω—ã–º–∏ –≤–µ–Ω–¥–æ—Ä–∞–º–∏ –Ω–∞ —Ä–µ–ø–æ-—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏

### –ú–∏—Ç–∏–≥–∞—Ü–∏—è:
- ‚úÖ –ù–∞—á–∞—Ç—å —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–æ–π
- ‚úÖ –ü–∞—Ä—Ç–Ω–µ—Ä—Å—Ç–≤–æ —Å CryptoPro/ViPNet –¥–ª—è –ì–û–°–¢
- ‚úÖ –§–æ–∫—É—Å –Ω–∞ —Ä–æ—Å—Å–∏–π—Å–∫–∏–π —Ä—ã–Ω–æ–∫ (–∏–º–ø–æ—Ä—Ç–æ–∑–∞–º–µ—â–µ–Ω–∏–µ)

---

**–ò—Ç–æ–≥–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞**: –í—Å–µ —Ç—Ä–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∞–∑–≤–∏—Ç–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã –∏ –æ–±–µ—Å–ø–µ—á–∞—Ç –ø—Ä–æ–µ–∫—Ç—É **–ª–∏–¥–∏—Ä—É—é—â—É—é –ø–æ–∑–∏—Ü–∏—é** –Ω–∞ —Ä—ã–Ω–∫–µ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–≥–æ –∞—É–¥–∏—Ç–∞ –≤ –†–æ—Å—Å–∏–∏ –∫ –∫–æ–Ω—Ü—É 2025 –≥–æ–¥–∞.
